#include <memory>
#include <iostream>

#include "http2_huffman.hpp"


namespace neosystem {
namespace http2 {

class huffman_node {
public:
	using ptr_type = huffman_node *;

	uint16_t value;

	ptr_type one;
	ptr_type zero;

	huffman_node(void) : value(256), one(nullptr), zero(nullptr) {
	}
};

class bit_reader  {
private:
	std::size_t index_;
	int bit_index_;

	std::size_t length_;
	const uint8_t *p_;

public:
	bit_reader(std::size_t length, const uint8_t *p) : index_(0), bit_index_(0), length_(length), p_(p) {
	}

	bool read(uint8_t& value) {
		if (index_ >= length_) return false;

		uint8_t t = p_[index_];
		value = t >> (8 - bit_index_ - 1) & 1;

		++bit_index_;
		if (bit_index_ == 8) {
			bit_index_ = 0;
			++index_;
		}
		return true;
	}
};

static huffman_node::ptr_type g_root;

void append_node(huffman_node::ptr_type, uint8_t, const char *);
void destruct_huffman_root_impl(huffman_node::ptr_type);

void destruct_huffman_root(void) {
	destruct_huffman_root_impl(g_root);
	return;
}

void destruct_huffman_root_impl(huffman_node::ptr_type node) {
	if (node == nullptr) return;

	destruct_huffman_root_impl(node->one);
	destruct_huffman_root_impl(node->zero);
	delete node;
	return;
}

void init_huffman(void) {
	std::string def[] = {
		"1111111111000",
		"11111111111111111011000",
		"1111111111111111111111100010",
		"1111111111111111111111100011",
		"1111111111111111111111100100",
		"1111111111111111111111100101",
		"1111111111111111111111100110",
		"1111111111111111111111100111",
		"1111111111111111111111101000",
		"111111111111111111101010",
		"111111111111111111111111111100",
		"1111111111111111111111101001",
		"1111111111111111111111101010",
		"111111111111111111111111111101",
		"1111111111111111111111101011",
		"1111111111111111111111101100",
		"1111111111111111111111101101",
		"1111111111111111111111101110",
		"1111111111111111111111101111",
		"1111111111111111111111110000",
		"1111111111111111111111110001",
		"1111111111111111111111110010",
		"111111111111111111111111111110",
		"1111111111111111111111110011",
		"1111111111111111111111110100",
		"1111111111111111111111110101",
		"1111111111111111111111110110",
		"1111111111111111111111110111",
		"1111111111111111111111111000",
		"1111111111111111111111111001",
		"1111111111111111111111111010",
		"1111111111111111111111111011",
		"010100",
		"1111111000",
		"1111111001",
		"111111111010",
		"1111111111001",
		"010101",
		"11111000",
		"11111111010",
		"1111111010",
		"1111111011",
		"11111001",
		"11111111011",
		"11111010",
		"010110",
		"010111",
		"011000",
		"00000",
		"00001",
		"00010",
		"011001",
		"011010",
		"011011",
		"011100",
		"011101",
		"011110",
		"011111",
		"1011100",
		"11111011",
		"111111111111100",
		"100000",
		"111111111011",
		"1111111100",
		"1111111111010",
		"100001",
		"1011101",
		"1011110",
		"1011111",
		"1100000",
		"1100001",
		"1100010",
		"1100011",
		"1100100",
		"1100101",
		"1100110",
		"1100111",
		"1101000",
		"1101001",
		"1101010",
		"1101011",
		"1101100",
		"1101101",
		"1101110",
		"1101111",
		"1110000",
		"1110001",
		"1110010",
		"11111100",
		"1110011",
		"11111101",
		"1111111111011",
		"1111111111111110000",
		"1111111111100",
		"11111111111100",
		"100010",
		"111111111111101",
		"00011",
		"100011",
		"00100",
		"100100",
		"00101",
		"100101",
		"100110",
		"100111",
		"00110",
		"1110100",
		"1110101",
		"101000",
		"101001",
		"101010",
		"00111",
		"101011",
		"1110110",
		"101100",
		"01000",
		"01001",
		"101101",
		"1110111",
		"1111000",
		"1111001",
		"1111010",
		"1111011",
		"111111111111110",
		"11111111100",
		"11111111111101",
		"1111111111101",
		"1111111111111111111111111100",
		"11111111111111100110",
		"1111111111111111010010",
		"11111111111111100111",
		"11111111111111101000",
		"1111111111111111010011",
		"1111111111111111010100",
		"1111111111111111010101",
		"11111111111111111011001",
		"1111111111111111010110",
		"11111111111111111011010",
		"11111111111111111011011",
		"11111111111111111011100",
		"11111111111111111011101",
		"11111111111111111011110",
		"111111111111111111101011",
		"11111111111111111011111",
		"111111111111111111101100",
		"111111111111111111101101",
		"1111111111111111010111",
		"11111111111111111100000",
		"111111111111111111101110",
		"11111111111111111100001",
		"11111111111111111100010",
		"11111111111111111100011",
		"11111111111111111100100",
		"111111111111111011100",
		"1111111111111111011000",
		"11111111111111111100101",
		"1111111111111111011001",
		"11111111111111111100110",
		"11111111111111111100111",
		"111111111111111111101111",
		"1111111111111111011010",
		"111111111111111011101",
		"11111111111111101001",
		"1111111111111111011011",
		"1111111111111111011100",
		"11111111111111111101000",
		"11111111111111111101001",
		"111111111111111011110",
		"11111111111111111101010",
		"1111111111111111011101",
		"1111111111111111011110",
		"111111111111111111110000",
		"111111111111111011111",
		"1111111111111111011111",
		"11111111111111111101011",
		"11111111111111111101100",
		"111111111111111100000",
		"111111111111111100001",
		"1111111111111111100000",
		"111111111111111100010",
		"11111111111111111101101",
		"1111111111111111100001",
		"11111111111111111101110",
		"11111111111111111101111",
		"11111111111111101010",
		"1111111111111111100010",
		"1111111111111111100011",
		"1111111111111111100100",
		"11111111111111111110000",
		"1111111111111111100101",
		"1111111111111111100110",
		"11111111111111111110001",
		"11111111111111111111100000",
		"11111111111111111111100001",
		"11111111111111101011",
		"1111111111111110001",
		"1111111111111111100111",
		"11111111111111111110010",
		"1111111111111111101000",
		"1111111111111111111101100",
		"11111111111111111111100010",
		"11111111111111111111100011",
		"11111111111111111111100100",
		"111111111111111111111011110",
		"111111111111111111111011111",
		"11111111111111111111100101",
		"111111111111111111110001",
		"1111111111111111111101101",
		"1111111111111110010",
		"111111111111111100011",
		"11111111111111111111100110",
		"111111111111111111111100000",
		"111111111111111111111100001",
		"11111111111111111111100111",
		"111111111111111111111100010",
		"111111111111111111110010",
		"111111111111111100100",
		"111111111111111100101",
		"11111111111111111111101000",
		"11111111111111111111101001",
		"1111111111111111111111111101",
		"111111111111111111111100011",
		"111111111111111111111100100",
		"111111111111111111111100101",
		"11111111111111101100",
		"111111111111111111110011",
		"11111111111111101101",
		"111111111111111100110",
		"1111111111111111101001",
		"111111111111111100111",
		"111111111111111101000",
		"11111111111111111110011",
		"1111111111111111101010",
		"1111111111111111101011",
		"1111111111111111111101110",
		"1111111111111111111101111",
		"111111111111111111110100",
		"111111111111111111110101",
		"11111111111111111111101010",
		"11111111111111111110100",
		"11111111111111111111101011",
		"111111111111111111111100110",
		"11111111111111111111101100",
		"11111111111111111111101101",
		"111111111111111111111100111",
		"111111111111111111111101000",
		"111111111111111111111101001",
		"111111111111111111111101010",
		"111111111111111111111101011",
		"1111111111111111111111111110",
		"111111111111111111111101100",
		"111111111111111111111101101",
		"111111111111111111111101110",
		"111111111111111111111101111",
		"111111111111111111111110000",
		"11111111111111111111101110",
		"111111111111111111111111111111",
	};

	g_root = new huffman_node();
	for (int i = 0; i < 256; ++i) {
		append_node(g_root, (uint8_t) i, def[i].c_str());
	}
	return;
}

void append_node(huffman_node::ptr_type node, uint8_t value, const char *code) {
	if (*code == '0') {
		++code;
		if (node->zero == nullptr) {
			node->zero = new huffman_node();
		}
		append_node(node->zero, value, code);
	} else if (*code == '1') {
		++code;
		if (node->one == nullptr) {
			node->one = new huffman_node();
		}
		append_node(node->one, value, code);
	} else if (*code == '\0') {
		node->value = value;
	}
	return;
}

bool decode_huffman(std::size_t length, const uint8_t *src, std::string& dst) {
	dst = "";
	bit_reader reader(length, src);
	auto node = g_root;
	int remain_count = 0;
	bool padding_flag = false;

	while (true) {
		uint8_t bit;
		if (reader.read(bit) == false) {
			break;
		}
		
		if (bit == 0) {
			node = node->zero;
		} else {
			node = node->one;
		}

		if (node == nullptr) {
			std::cout << "Invalid code" << std::endl;
			return false;
		}

		if (node->value < 256) {
			dst += (char) node->value;
			node = g_root;
			remain_count = 0;
			padding_flag = true;
		} else {
			++remain_count;
			if (bit == 0) {
				padding_flag = false;
			}
		}
	}
	if (padding_flag && remain_count > 7) {
		return false;
	} else if (padding_flag == false && remain_count > 0) {
		return false;
	}
	return true;
}

}
}
